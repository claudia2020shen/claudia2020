import numpy as np
import pandas as pd
import torch
import torch.nn as nn
import torch.optim as optim
from torch.utils.data import DataLoader, TensorDataset
from sklearn.preprocessing import MinMaxScaler
from torch.utils.data import Dataset

# 读取数据
def read_data(file_path):
    df = pd.read_csv(file_path)
    return df

# 准备数据
class PrepareData(Dataset):
    def __init__(self, data, target):
        self.data = data
        self.target = target

    def __len__(self):
        return len(self.target)

    def __getitem__(self, idx):
        return self.data[idx], self.target[idx]

# 定义模型
class SimpleModel(nn.Module):
    def __init__(self):
        super(SimpleModel, self).__init__()
        self.fc1 = nn.Linear(26, 16)
        self.fc2 = nn.Linear(16, 32)
        self.fc3 = nn.Linear(32, 32)
        self.fc4 = nn.Linear(32, 32)
        self.fc5 = nn.Linear(32, 1)

    def forward(self, x):
        x = torch.relu(self.fc1(x))
        x = torch.relu(self.fc2(x))
        x = torch.relu(self.fc3(x))
        x = torch.sigmoid(self.fc4(x))
        x = torch.sigmoid(self.fc5(x))
        return x

# 读取数据
df_data = read_data('...')
shuffled_df_data = df_data.sample(frac=1)

# 准备数据
x_data, y_data = shuffled_df_data.drop(['Number'], axis=1).values, shuffled_df_data['Number'].values
minmax_scale = MinMaxScaler(feature_range=(0, 1))
norm_features = minmax_scale.fit_transform(x_data)

# 创建数据集和数据加载器
train_dataset = PrepareData(norm_features, y_data)
train_loader = DataLoader(dataset=train_dataset, batch_size=40, shuffle=True)

# 创建模型
model = SimpleModel()
criterion = nn.BCELoss()
optimizer = optim.Adam(model.parameters(), lr=0.003)

# 训练模型
def train(model, device, train_loader, optimizer, criterion, epoch):
    model.train()
    for batch_idx, (data, target) in enumerate(train_loader):
        data, target = data.to(device), target.to(device)
        optimizer.zero_grad()
        output = model(data)
        loss = criterion(output, target.unsqueeze(1))
        loss.backward()
        optimizer.step()

# 设备配置（CPU或GPU）
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
model.to(device)

# 训练模型
epochs = 100
for epoch in range(1, epochs + 1):
    train(model, device, train_loader, optimizer, criterion, epoch)

# 评估模型
def evaluate(model, device, test_loader):
    model.eval()
    correct = 0
    total = 0
    with torch.no_grad():
        for data, target in test_loader:
            data, target = data.to(device), target.to(device)
            output = model(data)
            predicted = (output > 0.5).float()
            total += target.size(0)
            correct += (predicted == target).sum().item()
    return correct / total

# 测试模型
test_data

# 测试模型
test_data = read_data('...')
x_test, y_test = test_data.drop(['Number'], axis=1).values, test_data['Number'].values
minmax_scale = MinMaxScaler(feature_range=(0, 1))
norm_features_test = minmax_scale.fit_transform(x_test)

test_dataset = PrepareData(norm_features_test, y_test)
test_loader = DataLoader(dataset=test_dataset, batch_size=40, shuffle=False)

# 评估模型
def evaluate(model, device, test_loader):
    model.eval()
    correct = 0
    total = 0
    with torch.no_grad():
        for data, target in test_loader:
            data, target = data.to(device), target.to(device)
            output = model(data)
            predicted = (output > 0.5).float()
            total += target.size(0)
            correct += (predicted == target).sum().item()
    return correct / total

# 模型评估
accuracy = evaluate(model, device, test_loader)
print(f'Accuracy on test data: {accuracy * 100:.2f}%')

# 保存模型
torch.save(model.state_dict(), '------.pth')
